  CS 300 gave me an understanding of how data structures and algorithms impact software efficiency and organization. In the first place, I attempted to design a system that reads course data from a file, organizes it, and converts it into a format that can be easily understood by academic advisors. I also analyzed different data structures to figure out which ones were the best for storing and retrieving that kind of information.
  
  When I started Project One, I focused on understanding runtime and memory analysis for data structures like vectors, hash tables, and trees. I learned how to compare them based on how quickly they could insert, search, and retrieve data. This helped me see why choosing the right structure matters, not just for speed, but also for how much memory is used and how easily the program can scale.
  
  In Project Two, I applied those lessons by writing a C++ program that reads course data from a text file and sorts it alphanumerically. I used a vector of course objects and a bubble sort algorithm to keep it simple and readable. I also made sure the program handled input errors and provided user-friendly prompts through a clean console menu.
  
  There were definitely some roadblocks, especially with getting the file to load properly in Visual Studio and making sure the sorting worked exactly like the example output. I overcame that by carefully debugging, checking file paths, and breaking my code into smaller functions so it was easier to test piece by piece.
  
  These projects helped me improve not just my coding skills, but also my mindset as a developer. I learned to think more about how to design software thatâ€™s maintainable and easy to understand later on. I also paid more attention to naming conventions, modular code, and inline comments,  things that make code clearer for others and my future self to read.
  
  Overall, CS 300 expanded my understanding of how algorithms and data structures work together. I now feel more confident designing efficient solutions, troubleshooting problems, and writing clean, adaptable code that follows best practices.

